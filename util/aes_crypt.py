"""
Two-way encryption using AES with a key. Depends on pycryptodome.
"""
from argparse import ArgumentParser, ArgumentDefaultsHelpFormatter
from base64 import b64decode, b64encode
from Crypto.Cipher import AES
import os
from random import choices
from string import ascii_letters, digits


B62_CHARS = ascii_letters + digits
BS = 16
IV = '0123456789012345'


def create_key():
    """ Create a default key. """
    return ''.join(choices(B62_CHARS, k=16))


def pad(data):
    """ Pad the data for encryption. """
    return data + (BS - len(data) % BS) * chr(BS - len(data) % BS)


def unpad(data):
    """ Unpad the data after decryption. """
    return data[:-ord(data[len(data) - 1:])]


def encrypt(data, key):
    """ AES encrypt 'data' using 'key'. """
    b_data = str.encode(pad(data))
    cipher = AES.new(str.encode(key), AES.MODE_CBC, str.encode(IV))
    return b64encode(cipher.encrypt(b_data)).decode('utf-8')


def decrypt(data, key):
    """ AES decrypt 'data' using 'key'. """
    enc = b64decode(data)
    cipher = AES.new(str.encode(key), AES.MODE_CBC, str.encode(IV))
    return unpad(cipher.decrypt(enc)).decode('utf-8')


if __name__ == '__main__':

    parser = ArgumentParser(description=__doc__,
                            formatter_class=ArgumentDefaultsHelpFormatter)
    sub_parsers = parser.add_subparsers(
        dest="cmd",
        required=True,
        help='Command to run.')
    encrypt_parser = sub_parsers.add_parser(
        'encrypt',
        help="Encrypt the input.")
    encrypt_parser.add_argument(
        'input',
        help="Input to encrypt as either a string or file path.")
    encrypt_parser.add_argument(
        '--key',
        help="Key to use for encyption, generated by default.")
    decrypt_parser = sub_parsers.add_parser(
        'decrypt',
        help="Decrypt the input.")
    decrypt_parser.add_argument(
        'key',
        help="Key to use for decryption.")
    decrypt_parser.add_argument(
        'input',
        help="Input to decrypt as either a string or file path.")
    args = parser.parse_args()

    if args.cmd == 'encrypt':
        if args.key is None:
            key = create_key()
            print('-' * 80)
            print(f"key: {key}")
        else:
            key = args.key
        if os.path.exists(args.input):
            with open(args.input) as fi:
                data = fi.read()
            out_fp = os.path.join(
                os.path.basename(args.input),
                "_aes$enc$",
                os.path.splitext(args.input)[1])
            with open(out_fp, 'w') as fo:
                fo.print(encrypt(data, key))
        else:
            print('-' * 80)
            print(encrypt(args.input, key))
            print('-' * 80)
    else:
        key = args.key
        if os.path.exists(args.input):
            with open(args.input) as fi:
                data = fi.read()
            if "_aes$enc$" in args.input:
                out_fp = args.input.replace('_aes$enc$', '')
            else:
                out_fp = os.path.join(
                    os.path.basename(args.input),
                    "_aes$dec$",
                    os.path.splitext(args.input)[1])
        else:
            print('-' * 80)
            print(decrypt(args.input, key))
            print('-' * 80)
